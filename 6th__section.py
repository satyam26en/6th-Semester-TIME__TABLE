# -*- coding: utf-8 -*-
"""6th__section.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kAt7vHvMvcGB08cP7WKcSs4X6INlxr9n
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.io as pio
import random
import io

# Ensure kaleido is installed
try:
    import kaleido
except ImportError:
    st.error("kaleido is not installed. Please install it using 'pip install -U kaleido'")
    st.stop()

# Set page configuration
st.set_page_config(
    page_title="Student Timetable Viewer",
    layout="centered",
    initial_sidebar_state="expanded",
)

# Load the section, professional elective, and core section files from GitHub
section_url = 'https://raw.githubusercontent.com/satyam26en/6th-Semester-TIME__TABLE/main/section_list_6Th_semester%20-%20Sheet1.csv'
elective_url = 'https://raw.githubusercontent.com/satyam26en/TIME_TABLE_KIIT/main/Professional_Elective%20-%20Sheet1.csv'
core_url = 'https://raw.githubusercontent.com/satyam26en/6th-Semester-TIME__TABLE/main/6th_core%20-%20Sheet1.csv'

@st.cache_data
def load_data(url):
    return pd.read_csv(url)

section_df = load_data(section_url)
elective_df = load_data(elective_url)
core_df = load_data(core_url)

# Normalize the 'Roll No.' column to ensure there are no leading/trailing spaces and consistent data type
section_df['Roll No.'] = section_df['Roll No.'].astype(str).str.strip()

# Define the order of days and times
days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
times = ['8 TO 9', '9 TO 10', '10 TO 11', '11 TO 12', '12 TO 1', '1 TO 2', '2 TO 3', '3 TO 4', '4 TO 5']

# Define a mapping from abbreviated to full day names
day_mapping = {
    'MON': 'Monday',
    'TUE': 'Tuesday',
    'WED': 'Wednesday',
    'THU': 'Thursday',
    'FRI': 'Friday',
    'SAT': 'Saturday'
}

# Function to standardize time slot names
def standardize_time_slot(time_slot):
    time_slot_mapping = {
        '8 TO 9': '8 TO 9',
        '9 TO 10': '9 TO 10',
        '10 TO 11': '10 TO 11',
        '11 TO 12': '11 TO 12',
        '12 TO 1': '12 TO 1',
        '1 TO 2': '1 TO 2',
        '2 TO 3': '2 TO 3',
        '3 TO 4': '3 TO 4',
        '4 TO 5': '4 TO 5'
    }
    # Remove extra spaces in the time slot string to match the mapping
    standardized_slot = ' '.join(time_slot.upper().split())
    return time_slot_mapping.get(standardized_slot, time_slot)

# Define multiple color schemes
color_schemes = [
    {
        'header_fill': '#1abc9c',      # Turquoise
        'header_text': 'white',
        'time_fill': '#16a085',        # Dark Turquoise
        'time_text': 'white',
        'day_fill_1': '#ecf0f1',       # Light Grey
        'day_fill_2': '#bdc3c7',       # Silver
        'day_text': '#2c3e50'          # Midnight Blue
    },
    {
        'header_fill': '#e74c3c',      # Alizarin
        'header_text': 'white',
        'time_fill': '#c0392b',        # Pomegranate
        'time_text': 'white',
        'day_fill_1': '#fdfefe',       # Snow
        'day_fill_2': '#dfe6e9',       # Light Blue Grey
        'day_text': '#2d3436'          # Dark Grey
    },
    {
        'header_fill': '#8e44ad',      # Wisteria
        'header_text': 'white',
        'time_fill': '#732d91',        # Purple Heart
        'time_text': 'white',
        'day_fill_1': '#f5f6f4',       # Platinum
        'day_fill_2': '#dcdde1',       # Light Grey
        'day_text': '#2c3e50'          # Midnight Blue
    },
    {
        'header_fill': '#2980b9',      # Belize Hole
        'header_text': 'white',
        'time_fill': '#1f618d',        # Blue Dianne
        'time_text': 'white',
        'day_fill_1': '#f0f3f4',       # Platinum
        'day_fill_2': '#dcdde1',       # Light Grey
        'day_text': '#2c3e50'          # Midnight Blue
    },
    {
        'header_fill': '#27ae60',      # Green Sea
        'header_text': 'white',
        'time_fill': '#1e8449',        # Dark Green
        'time_text': 'white',
        'day_fill_1': '#f8f9fa',       # Ghost White
        'day_fill_2': '#dfe6e9',       # Light Blue Grey
        'day_text': '#2c3e50'          # Midnight Blue
    }
]

# Function to generate the timetable dataframe
def generate_timetable_df(roll_number):
    # Find the section details for the given roll number
    student_section = section_df[section_df['Roll No.'] == roll_number]

    if student_section.empty:
        st.error("Roll number not found.")
        return None

    # Extract the core section and elective sections
    core_section = student_section['Core Section'].values[0]
    elective_1_section = student_section['Professional Elective 1'].values[0]
    elective_2_section = student_section['Professional Elective 2'].values[0]

    # Retrieve the weekly timetable for Professional Electives 1 and 2
    elective_1_timetable = elective_df[elective_df['Section(DE)'] == elective_1_section]
    elective_2_timetable = elective_df[elective_df['Section(DE)'] == elective_2_section]
    core_timetable = core_df[core_df['Section'] == core_section]

    # Initialize the timetable matrix
    timetable_matrix = pd.DataFrame(index=times, columns=days, data='')

    # Function to fill the timetable matrix with subject names and room numbers
    def fill_timetable(timetable_df):
        room_columns = [col for col in timetable_df.columns if 'ROOM' in col]
        for index, row in timetable_df.iterrows():
            day = day_mapping.get(row['DAY'], 'Unknown')
            if day == 'Unknown':
                continue  # Skip if day is not in the mapping
            for col in room_columns:
                if row[col] != '---':
                    time_col_index = timetable_df.columns.get_loc(col) + 1
                    if time_col_index >= len(timetable_df.columns):
                        continue  # Prevent index out of range
                    time_col = timetable_df.columns[time_col_index]
                    time_slot = standardize_time_slot(time_col)
                    subject = row.get(time_col, 'N/A')
                    room_number = row[col]
                    if isinstance(subject, str) and subject.lower() != 'x':  # Only include if it's not 'x'
                        # Append to existing entry if there's a conflict
                        existing_entry = timetable_matrix.at[time_slot, day]
                        new_entry = f"{subject} ({room_number})"
                        if existing_entry:
                            timetable_matrix.at[time_slot, day] = existing_entry + "<br>" + new_entry
                        else:
                            timetable_matrix.at[time_slot, day] = new_entry

    # Fill the timetable matrix for core and elective timetables
    fill_timetable(core_timetable)
    fill_timetable(elective_1_timetable)
    fill_timetable(elective_2_timetable)

    # Replace NaN values with blank spaces
    timetable_matrix = timetable_matrix.fillna('')

    # Sort the table based on time slots
    timetable_matrix = timetable_matrix.reindex(times)

    return timetable_matrix

# Function to visualize the timetable using Plotly with random color schemes
def visualize_timetable(timetable_matrix):
    if timetable_matrix is None:
        return None

    # Randomly select a color scheme
    selected_scheme = random.choice(color_schemes)

    # Create bold Time column by wrapping with <b> tags
    bold_time_slots = [f"<b>{time}</b>" for time in timetable_matrix.index]

    # Create the table
    fig = go.Figure(data=[go.Table(
        columnwidth = [100] + [120]*6,
        header=dict(
            values=['<b>Time</b>'] + [f'<b>{day}</b>' for day in days],
            fill_color=selected_scheme['header_fill'],
            align='center',
            font=dict(color=selected_scheme['header_text'], size=14, family='Arial Black'),
            height=50
        ),
        cells=dict(
            values=[bold_time_slots] + [timetable_matrix[day].tolist() for day in days],
            fill=dict(
                color=[
                    [selected_scheme['time_fill']] * len(times),  # Time column with selected fill color
                    *[
                        [selected_scheme['day_fill_1']] * len(times) if i % 2 == 0 else [selected_scheme['day_fill_2']] * len(times)
                        for i in range(len(days))
                    ]
                ]
            ),
            align='center',
            font=dict(
                color=[
                    selected_scheme['time_text']
                ] + [
                    [selected_scheme['day_text']] * len(times) for _ in days
                ],
                size=12,
                family='Arial'
            ),
            height=40,
            line_color='rgba(0,0,0,0.1)',
            line_width=1
        )
    )])

    # Add title with enhanced styling
    fig.update_layout(
        title=dict(
            text='ðŸ“… Student Timetable',
            x=0.5,
            xanchor='center',
            font=dict(size=24, family='Arial Black', color='teal')
        ),
        margin=dict(l=20, r=20, t=60, b=20),
        height=700,
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        font=dict(family='Arial')
    )

    return fig

# Streamlit App

# Apply custom CSS for background color and fonts
st.markdown(
    """
    <style>
    .reportview-container {
        background: #ecf0f1;
        color: #2c3e50;
    }
    .sidebar .sidebar-content {
        background: #2c3e50;
        color: white;
    }
    h1 {
        font-family: 'Arial Black', sans-serif;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# Display logo
st.image('https://raw.githubusercontent.com/satyam26en/TIME_TABLE_KIIT/main/KIIT-Full-Logo-Center.png', use_column_width=True)

st.title('Student Timetable Viewer')

# User input for Roll Number
roll_number = st.text_input("Enter Roll Number", max_chars=10)

# Checkbox for downloading timetable as JPG
download = st.checkbox("Download timetable as JPG image")

st.markdown("<br>", unsafe_allow_html=True)  # Add a line break for spacing

if st.button("Generate Timetable"):
    if roll_number:
        fig = visualize_timetable(generate_timetable_df(roll_number))
        if fig:
            st.plotly_chart(fig, use_container_width=True)
            if download:
                try:
                    img_bytes = fig.to_image(format='jpg')
                    st.download_button(
                        label="Download timetable as JPG",
                        data=img_bytes,
                        file_name="timetable.jpg",
                        mime="image/jpg"
                    )
                    st.success("Timetable has been prepared for download.")
                except Exception as e:
                    st.error(f"Error saving image: {e}")
    else:
        st.error("Please enter a roll number.")