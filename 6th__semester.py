# -*- coding: utf-8 -*-
"""6th__semester.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kAt7vHvMvcGB08cP7WKcSs4X6INlxr9n
"""
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import random
from io import BytesIO
from PIL import Image
import requests

# Set Streamlit page configuration
st.set_page_config(
    page_title="üéì Student Timetable Viewer",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Define all background images (excluding images 9 and 10)
background_images = [
    # Image 1
    {
        'description': 'Motivational Quote',
        'url': "https://images.unsplash.com/photo-1522202176988-66273c2fd55f?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 2
    {
        'description': 'Classroom Environment',
        'url': "https://images.unsplash.com/photo-1503676260728-1c00da094a0b?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 3
    {
        'description': 'Lecture Hall Setup',
        'url': "https://images.unsplash.com/photo-1529333166437-7750a6dd5a70?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 4
    {
        'description': 'Motivational Study Setup',
        'url': "https://images.unsplash.com/photo-1496307042754-b4aa456c4a2d?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 5
    {
        'description': 'Students Collaborating',
        'url': "https://images.unsplash.com/photo-1515378791036-0648a3ef77b2?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 6
    {
        'description': 'Vibrant Student Life',
        'url': "https://images.unsplash.com/photo-1522071820081-009f0129c71c?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 7
    {
        'description': 'Graduation Ceremony',
        'url': "https://images.unsplash.com/photo-1524995997946-a1c2e315a42f?auto=format&fit=crop&w=1950&q=80"
    },
    # Image 8 - Taylor Swift
    {
        'description': 'Taylor Swift MetLife Opening',
        'url': "https://www.rollingstone.com/wp-content/uploads/2023/05/taylor-swift-metlife-opening.jpg?w=1581&h=1054&crop=1"
    }
]

# Define multiple themes, each with a unique color scheme and associated background image
themes = [
    {
        'name': 'Motivational',
        'color_scheme': {
            'header_fill': '#FF5733',
            'header_text': '#ffffff',
            'time_fill': '#C70039',
            'time_text': '#ffffff',
            'day_fill_1': '#FFC300',
            'day_fill_2': '#FF5733',
            'day_text': '#900C3F',
        },
        'background_image': background_images[0]['url']  # Image 1
    },
    {
        'name': 'Academic',
        'color_scheme': {
            'header_fill': '#3498DB',
            'header_text': '#ffffff',
            'time_fill': '#2980B9',
            'time_text': '#ffffff',
            'day_fill_1': '#85C1E9',
            'day_fill_2': '#2980B9',
            'day_text': '#1A5276',
        },
        'background_image': background_images[1]['url']  # Image 2
    },
    {
        'name': 'Lecture',
        'color_scheme': {
            'header_fill': '#8E44AD',
            'header_text': '#ffffff',
            'time_fill': '#732D91',
            'time_text': '#ffffff',
            'day_fill_1': '#D2B4DE',
            'day_fill_2': '#8E44AD',
            'day_text': '#5B2C6F',
        },
        'background_image': background_images[2]['url']  # Image 3
    },
    {
        'name': 'Study',
        'color_scheme': {
            'header_fill': '#27AE60',
            'header_text': '#ffffff',
            'time_fill': '#1E8449',
            'time_text': '#ffffff',
            'day_fill_1': '#ABEBC6',
            'day_fill_2': '#27AE60',
            'day_text': '#145A32',
        },
        'background_image': background_images[3]['url']  # Image 4
    },
    {
        'name': 'Collaboration',
        'color_scheme': {
            'header_fill': '#F39C12',
            'header_text': '#ffffff',
            'time_fill': '#D68910',
            'time_text': '#ffffff',
            'day_fill_1': '#FDEBD0',
            'day_fill_2': '#F5CBA7',
            'day_text': '#A04000',
        },
        'background_image': background_images[4]['url']  # Image 5
    },
    {
        'name': 'Vibrant',
        'color_scheme': {
            'header_fill': '#E74C3C',
            'header_text': '#ffffff',
            'time_fill': '#C0392B',
            'time_text': '#ffffff',
            'day_fill_1': '#F1948A',
            'day_fill_2': '#EC7063',
            'day_text': '#641E16',
        },
        'background_image': background_images[5]['url']  # Image 6
    },
    {
        'name': 'Graduation',
        'color_scheme': {
            'header_fill': '#2ECC71',
            'header_text': '#ffffff',
            'time_fill': '#27AE60',
            'time_text': '#ffffff',
            'day_fill_1': '#A9DFBF',
            'day_fill_2': '#2ECC71',
            'day_text': '#145A32',
        },
        'background_image': background_images[6]['url']  # Image 7
    },
    {
        'name': 'Taylor Swift',
        'color_scheme': {
            'header_fill': '#FF69B4',  # Hot Pink
            'header_text': '#ffffff',
            'time_fill': '#FF1493',     # Deep Pink
            'time_text': '#ffffff',
            'day_fill_1': '#ffe4e1',    # Misty Rose
            'day_fill_2': '#ffb6c1',    # Light Pink
            'day_text': '#2c3e50',
        },
        'background_image': background_images[7]['url']  # Image 8
    },
]

# Function to select theme based on user selection
def select_theme():
    st.sidebar.title("üé® Theme Selection")
    theme_names = [theme['name'] for theme in themes]
    selected_theme_name = st.sidebar.selectbox("Choose a Theme", theme_names, index=random.randint(0, len(themes)-1))
    selected_theme = next((theme for theme in themes if theme['name'] == selected_theme_name), themes[0])
    return selected_theme

# Function to calculate average brightness
def calculate_average_brightness(image):
    # Convert image to grayscale
    grayscale_image = image.convert("L")
    # Resize image to reduce computation
    grayscale_image = grayscale_image.resize((100, 100))
    # Get pixel data
    pixels = list(grayscale_image.getdata())
    # Calculate average brightness
    avg_brightness = sum(pixels) / len(pixels)
    return avg_brightness

# Function to add background and set text color
def add_background_and_set_text_color(img, selected_background_url):
    if img is None:
        return "#000000"  # Default to black

    # Calculate the average brightness
    avg_brightness = calculate_average_brightness(img)

    # Determine text color based on brightness
    text_color = "#000000" if avg_brightness > 127 else "#FFFFFF"

    # Inject custom CSS to set the background image
    st.markdown(
        f"""
        <style>
        .stApp {{
            background-image: url("{selected_background_url}");
            background-attachment: fixed;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }}
        </style>
        """,
        unsafe_allow_html=True
    )

    return text_color

# Function to load background image with caching
@st.cache_data
def get_background_image(url):
    try:
        response = requests.get(url)
        response.raise_for_status()
        img = Image.open(BytesIO(response.content))
        return img
    except Exception as e:
        st.error(f"‚ùå Failed to load background image: {e}")
        return None

# Function to load data from GitHub with fallback
@st.cache_data
def load_data(url, fallback_path=None):
    try:
        df = pd.read_csv(url)
        return df
    except Exception as e:
        st.warning(f"‚ùå Error loading data from {url}: {e}")
        if fallback_path:
            try:
                df = pd.read_csv(fallback_path)
                st.info("‚úÖ Loaded data from fallback source.")
                return df
            except Exception as fe:
                st.error(f"‚ùå Failed to load fallback data: {fe}")
        return None

# Function to validate dataframe
def validate_dataframe(df, expected_columns):
    if not all(column in df.columns for column in expected_columns):
        st.error("‚ùå Dataframe is missing expected columns.")
        return False
    return True

# URLs of the CSV files (Ensure these URLs are correct and publicly accessible)
section_url = 'https://raw.githubusercontent.com/satyam26en/6th-Semester-TIME__TABLE/main/section_list_6Th_semester%20-%20Sheet1.csv'
elective_url = 'https://raw.githubusercontent.com/satyam26en/TIME_TABLE_KIIT/main/Professional_Elective%20-%20Sheet1.csv'
core_url = 'https://raw.githubusercontent.com/satyam26en/6th-Semester-TIME__TABLE/main/6th_core%20-%20Sheet1.csv'

# Load data with optional fallbacks
section_df = load_data(section_url, fallback_path='data/section_list.csv')
elective_df = load_data(elective_url, fallback_path='data/elective.csv')
core_df = load_data(core_url, fallback_path='data/core.csv')

# Validate dataframes
if not all([
    section_df is not None and validate_dataframe(section_df, ['Roll No.', 'Core Section', 'Professional Elective 1', 'Professional Elective 2']),
    elective_df is not None and validate_dataframe(elective_df, ['DAY', 'ROOM1', 'TIME1', 'SUBJECT1']),  # Update expected columns accordingly
    core_df is not None and validate_dataframe(core_df, ['DAY', 'ROOM', 'TIME', 'SUBJECT'])  # Update expected columns accordingly
]):
    st.stop()

# Normalize the 'Roll No.' column to ensure consistency
section_df['Roll No.'] = section_df['Roll No.'].astype(str).str.strip()

# Define the order of days and times
days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
times = ['8 TO 9', '9 TO 10', '10 TO 11', '11 TO 12', '12 TO 1', '1 TO 2', '2 TO 3', '3 TO 4', '4 TO 5']

# Define a mapping from abbreviated to full day names
day_mapping = {
    'MON': 'Monday',
    'TUE': 'Tuesday',
    'WED': 'Wednesday',
    'THU': 'Thursday',
    'FRI': 'Friday',
    'SAT': 'Saturday'
}

# Function to standardize time slot names
def standardize_time_slot(time_slot):
    return time_slot.strip().upper()

# Function to generate the timetable dataframe
def generate_timetable_df(roll_number):
    # Find the section details for the given roll number
    student_section = section_df[section_df['Roll No.'] == roll_number]

    if student_section.empty:
        st.error("‚ùå Roll number not found. Please check and try again.")
        return None

    # Extract the core section and elective sections
    core_section = student_section['Core Section'].values[0]
    elective_1_section = student_section['Professional Elective 1'].values[0]
    elective_2_section = student_section['Professional Elective 2'].values[0]

    # Retrieve the weekly timetable for Professional Electives 1 and 2
    elective_1_timetable = elective_df[elective_df['Section(DE)'] == elective_1_section]
    elective_2_timetable = elective_df[elective_df['Section(DE)'] == elective_2_section]
    core_timetable = core_df[core_df['Section'] == core_section]

    # Initialize the timetable matrix
    timetable_matrix = pd.DataFrame(index=times, columns=days, data='')

    # Function to fill the timetable matrix with subject names and room numbers
    def fill_timetable(timetable_df):
        room_columns = [col for col in timetable_df.columns if 'ROOM' in col]
        for index, row in timetable_df.iterrows():
            day_abbr = row.get('DAY', '').upper()
            day = day_mapping.get(day_abbr, 'Unknown')
            if day == 'Unknown':
                continue  # Skip if day is not in the mapping
            for col in room_columns:
                if row[col] != '---':
                    # Assuming the time slot is in the corresponding TIME column
                    time_col = col.replace('ROOM', 'TIME')
                    time_slot = standardize_time_slot(row.get(time_col, ''))
                    subject = row.get(col.replace('ROOM', 'SUBJECT'), 'N/A')
                    room_number = row[col]
                    if isinstance(subject, str) and subject.lower() != 'x' and time_slot in times:
                        # Append to existing entry if there's a conflict
                        existing_entry = timetable_matrix.at[time_slot, day]
                        # Wrap subject in <b> tags for bold text
                        new_entry = f"<b>{subject} ({room_number})</b>"
                        if existing_entry:
                            timetable_matrix.at[time_slot, day] = existing_entry + "<br>" + new_entry
                        else:
                            timetable_matrix.at[time_slot, day] = new_entry

    # Fill the timetable matrix for core and elective timetables
    fill_timetable(core_timetable)
    fill_timetable(elective_1_timetable)
    fill_timetable(elective_2_timetable)

    # Replace NaN values with blank spaces
    timetable_matrix = timetable_matrix.fillna('')

    # Sort the table based on time slots
    timetable_matrix = timetable_matrix.reindex(times)

    return timetable_matrix

# Function to visualize the timetable using Plotly with selected color schemes
def visualize_timetable(timetable_matrix, color_scheme):
    if timetable_matrix is None:
        return None

    # Create bold Time column by wrapping with <b> tags
    bold_time_slots = [f"<b>{time}</b>" for time in timetable_matrix.index]

    # Create the table
    fig = go.Figure(data=[go.Table(
        # Removed fixed columnwidth to allow automatic adjustment
        header=dict(
            values=['<b>TIME</b>'] + [f'<b>{day.upper()}</b>' for day in days],
            fill_color=color_scheme['header_fill'],
            align='center',
            font=dict(color=color_scheme['header_text'], size=14, family='Arial Black'),
            height=50
        ),
        cells=dict(
            values=[bold_time_slots] + [timetable_matrix[day].tolist() for day in days],
            fill=dict(
                color=[
                    [color_scheme['time_fill']] * len(times),  # Time column
                    *[
                        [color_scheme['day_fill_1']] * len(times) if i % 2 == 0 else [color_scheme['day_fill_2']] * len(times)
                        for i in range(len(days))
                    ]
                ]
            ),
            align='center',
            font=dict(
                color=[
                    color_scheme['time_text']
                ] + [
                    [color_scheme['day_text']] * len(times) for _ in days
                ],
                size=10,  # Reduced font size for better fit on smaller screens
                family='Arial'
            ),
            height=40,
            line_color='rgba(0,0,0,0.1)',
            line_width=1
        )
    )])

    # Update layout for better responsiveness
    fig.update_layout(
        title=dict(
            text='üìÖ Student Timetable',
            x=0.5,
            xanchor='center',
            font=dict(size=24, family='Arial Black', color='teal')
        ),
        margin=dict(l=20, r=20, t=60, b=20),
        # Removed fixed height to allow automatic sizing
        paper_bgcolor='rgba(0,0,0,0)',  # Transparent paper background
        plot_bgcolor='rgba(0,0,0,0)',   # Transparent plot background
        font=dict(family='Arial')
    )

    return fig

# Function to save the timetable as an image
def save_timetable_as_image(fig, filename='timetable.jpg'):
    if fig is None:
        st.error("‚ùå No figure to save.")
        return
    try:
        img_bytes = fig.to_image(format='jpg')
        return img_bytes
    except Exception as e:
        st.error(f"‚ùå Error saving image: {e}")
        return None

# Function to display download button in Streamlit
def create_download_button(img_bytes, filename='timetable.jpg'):
    if not img_bytes:
        st.error("‚ùå No image to download.")
        return
    st.download_button(
        label="üì• Download Timetable as JPG",
        data=img_bytes,
        file_name=filename,
        mime="image/jpg",
        key='download-button'
    )

# Main Streamlit App
def main():
    # Select theme
    selected_theme = select_theme()
    color_scheme = selected_theme['color_scheme']
    background_image_url = selected_theme['background_image']

    # Load and set background
    img = get_background_image(background_image_url)
    if img:
        text_color = add_background_and_set_text_color(img, background_image_url)
    else:
        text_color = "#000000"  # Fallback color

    # Inject CSS for responsiveness
    st.markdown(
        """
        <style>
        /* Make Plotly charts responsive */
        .plotly-container {
            width: 100% !important;
            height: auto !important;
        }

        /* Enable horizontal scrolling for tables on small screens */
        @media only screen and (max-width: 600px) {
            .plotly {
                overflow-x: auto;
            }
            .plotly .main-svg {
                font-size: 8px !important;  /* Reduce font size */
            }
        }

        /* Adjust background image for smaller screens */
        @media only screen and (max-width: 600px) {
            .stApp {
                background-size: contain;
            }
        }
        </style>
        """,
        unsafe_allow_html=True
    )

    # Display the dynamic title with determined text color
    st.markdown(
        f"<h1 style='text-align: center; color: {text_color};'>üéì Student Timetable Viewer</h1>",
        unsafe_allow_html=True
    )

    # Display the "Enter Your Roll Number" label as bold and colored
    st.markdown(
        f"<h3 style='text-align: center; color: {text_color};'><b>Enter Your Roll Number</b></h3>",
        unsafe_allow_html=True
    )

    # User input for Roll Number without a label
    roll_number = st.text_input("", max_chars=10, key='roll_number_input')

    # Checkbox for downloading timetable as JPG
    download = st.checkbox("üì• Download timetable as JPG image")

    # Button to generate timetable
    if st.button("üîç Generate Timetable"):
        if roll_number.strip():
            with st.spinner('Generating timetable...'):
                timetable_df = generate_timetable_df(roll_number.strip())
                if timetable_df is not None:
                    fig = visualize_timetable(timetable_df, color_scheme)
                    if fig:
                        # Wrap the chart in a scrollable div for smaller screens
                        st.markdown(
                            """
                            <div style="overflow-x: auto;">
                            """,
                            unsafe_allow_html=True
                        )
                        st.plotly_chart(fig, use_container_width=True)
                        st.markdown(
                            """
                            </div>
                            """,
                            unsafe_allow_html=True
                        )
                        if download:
                            img_bytes = save_timetable_as_image(fig)
                            if img_bytes:
                                create_download_button(img_bytes)
        else:
            st.error("‚ùå Please enter a valid roll number.")

    # Footer - Hide Streamlit's default footer
    hide_streamlit_style = """
                <style>
                footer {visibility: hidden;}
                </style>
                """
    st.markdown(hide_streamlit_style, unsafe_allow_html=True)

if __name__ == "__main__":
    main()

